<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lebron James</title>
  
  <subtitle>知过必改 得能莫忘 罔谈彼短 靡恃己长 信使可覆 器欲难量</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://RunnanZhang.github.io/"/>
  <updated>2018-08-30T14:37:31.404Z</updated>
  <id>http://RunnanZhang.github.io/</id>
  
  <author>
    <name>奇念实难言</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>修改QMenu中的Icon大小</title>
    <link href="http://RunnanZhang.github.io/qt-custom-menu-iconsize/"/>
    <id>http://RunnanZhang.github.io/qt-custom-menu-iconsize/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-08-30T14:37:31.404Z</updated>
    
    <content type="html"><![CDATA[<p>提到<code>QMenu</code>中如何定制<code>Icon</code>的大小，第一个想到的是使用<code>qss</code>来修改样式，便尝试了如下语句：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">QMenu</span><span class="selector-pseudo">::icon</span></div><div class="line">&#123; </div><div class="line">    <span class="attribute">width</span>: <span class="number">24px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">24px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是经尝试，这个办法并未奏效，<code>QMenu</code>中图标大小，默认为16*16，是从<code>QStyle</code>中读取而来，我们可以通过自定义一个<code>QStyle</code>来实现修改图标大小，下面给出具体实现方式。</p><a id="more"></a> <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStyle</span> :</span> <span class="keyword">public</span> QProxyStyle</div><div class="line">&#123;</div><div class="line">    Q_OBJECT</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">pixelMetric</span><span class="params">(PixelMetric metric, <span class="keyword">const</span> QStyleOption *option, <span class="keyword">const</span> QWidget *widget)</span> <span class="keyword">const</span></span>;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (metric == QStyle::PM_SmallIconSize) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">24</span>;</div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> QProxyStyle::pixelMetric(metric, option, widget);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>然后将自定义风格设置到<code>QMenu</code>上即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">QMenu *menu = <span class="keyword">new</span> QMenu(<span class="keyword">this</span>);  </div><div class="line">CustomStyle *style = <span class="keyword">new</span> CustomStyle();  </div><div class="line">menu-&gt;setStyle(style);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到&lt;code&gt;QMenu&lt;/code&gt;中如何定制&lt;code&gt;Icon&lt;/code&gt;的大小，第一个想到的是使用&lt;code&gt;qss&lt;/code&gt;来修改样式，便尝试了如下语句：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;QMenu&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;::icon&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;24px&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;24px&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是经尝试，这个办法并未奏效，&lt;code&gt;QMenu&lt;/code&gt;中图标大小，默认为16*16，是从&lt;code&gt;QStyle&lt;/code&gt;中读取而来，我们可以通过自定义一个&lt;code&gt;QStyle&lt;/code&gt;来实现修改图标大小，下面给出具体实现方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt中系统相关翻译</title>
    <link href="http://RunnanZhang.github.io/qt-system-translate/"/>
    <id>http://RunnanZhang.github.io/qt-system-translate/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-04-07T14:13:09.252Z</updated>
    
    <content type="html"><![CDATA[<p>Qt中系统控件如何进行翻译呢，Qt的发布包中其实是有相关的翻译文件，源文件<code>.ts</code>以及二进制版本<code>.qm</code>都是有提供的。我们可以在发布路径下找到qm文件，以<code>Qt5.7</code>为例，即<code>C:/Qt/5.7/msvc2015_64/translations/qt_zh_CN.qm</code></p><p>但是这个文件时有缺失的，所以我们为了翻译的完全，以及更好地体验，需要自行修改<code>ts</code>文件，在原有的<code>ts</code>文件末尾追加一些翻译，然后利用<code>lrelease</code>自行生成<code>.qm</code>文件。官方的<code>.ts</code>文件一般位于源码路径下，例如<code>C:/Qt/5.9.1/Src/qttranslations/translations/qt_zh_CN.ts</code>。下面列举三个Qt并未进行翻译的地方，我们只需将下面给出的<code>xml</code>源码，复制到<code>ts</code>文件中相应位置即可。</p><a id="more"></a> <h2 id="1、关于QColorDialog中屏幕选择操作"><a href="#1、关于QColorDialog中屏幕选择操作" class="headerlink" title="1、关于QColorDialog中屏幕选择操作"></a>1、关于<code>QColorDialog</code>中屏幕选择操作</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">   <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;Pick Screen Color<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>获取屏幕颜色<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Cursor at %1, %2</div><div class="line">Press ESC to cancel<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>坐标: %1, %2</div><div class="line">按ESC键取消<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div></pre></td></tr></table></figure><p>注意因为源码中有<code>\n</code>换行，所以格式必须按上述来写，换行不可省略。将此段代码，嵌入到原<code>ts</code>文件的<code>QColorDialog</code>中的<code>context</code>段即可。</p><h2 id="2、关于一些右键菜单（如树节点的右键菜单）"><a href="#2、关于一些右键菜单（如树节点的右键菜单）" class="headerlink" title="2、关于一些右键菜单（如树节点的右键菜单）"></a>2、关于一些右键菜单（如树节点的右键菜单）</h2><p>将如下代码直接复制到<code>ts</code>文件尾部即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>QWidgetTextControl<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;Undo<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>撤销(&amp;amp;U)<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;Redo<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>恢复(&amp;amp;R)<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Cu&amp;amp;t<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>剪切(&amp;amp;T)<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;Copy<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>复制(&amp;amp;C)<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Copy &amp;amp;Link Location<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>复制链接位置(&amp;amp;L)<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;Paste<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>粘贴(&amp;amp;P)<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Select All<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>选择全部<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="3、QMessageBox中的按钮"><a href="#3、QMessageBox中的按钮" class="headerlink" title="3、QMessageBox中的按钮"></a>3、<code>QMessageBox</code>中的按钮</h2><p>一个很困惑的事情，<code>QMessageBox</code>中的按钮的翻译并不在<code>QDialogButton</code>中，费了一番周折，查找源码发现，在<code>QPlatformTheme</code>这个类中进行的翻译。将如下代码直接复制到<code>ts</code>文件尾部即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>QPlatformTheme<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Save All<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>保存全部<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>打开<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;Yes<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>&amp;amp;是<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Yes to &amp;amp;All<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>全部&amp;amp;是<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>&amp;amp;No<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>&amp;amp;否<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>N&amp;amp;o to All<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>&amp;amp;全部否<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Abort<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>终止<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Retry<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>重试<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Ignore<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>忽略<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Discard<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>放弃<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Help<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>帮助<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Apply<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>应用<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Reset<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>Restore Defaults<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">translation</span>&gt;</span>恢复默认<span class="tag">&lt;/<span class="name">translation</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Qt中系统控件如何进行翻译呢，Qt的发布包中其实是有相关的翻译文件，源文件&lt;code&gt;.ts&lt;/code&gt;以及二进制版本&lt;code&gt;.qm&lt;/code&gt;都是有提供的。我们可以在发布路径下找到qm文件，以&lt;code&gt;Qt5.7&lt;/code&gt;为例，即&lt;code&gt;C:/Qt/5.7/msvc2015_64/translations/qt_zh_CN.qm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是这个文件时有缺失的，所以我们为了翻译的完全，以及更好地体验，需要自行修改&lt;code&gt;ts&lt;/code&gt;文件，在原有的&lt;code&gt;ts&lt;/code&gt;文件末尾追加一些翻译，然后利用&lt;code&gt;lrelease&lt;/code&gt;自行生成&lt;code&gt;.qm&lt;/code&gt;文件。官方的&lt;code&gt;.ts&lt;/code&gt;文件一般位于源码路径下，例如&lt;code&gt;C:/Qt/5.9.1/Src/qttranslations/translations/qt_zh_CN.ts&lt;/code&gt;。下面列举三个Qt并未进行翻译的地方，我们只需将下面给出的&lt;code&gt;xml&lt;/code&gt;源码，复制到&lt;code&gt;ts&lt;/code&gt;文件中相应位置即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Nginx使用以及相关配置</title>
    <link href="http://RunnanZhang.github.io/linux-nginx-config/"/>
    <id>http://RunnanZhang.github.io/linux-nginx-config/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-01-01T15:28:09.840Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx（发音同engine x）是一个 Web服务器，也可以用作反向代理，负载平衡器和 HTTP缓存。本文主要介绍下nginx的使用方法，以及如何在一台服务器上配置多个域名和端口。</p><blockquote><p>关于nginx的相关应用场景我们这里不做详细说明，介绍两个相关名词，常见用于搭建web服务器的两种架构：</p><ul><li>LNMP指的是：Linux + Nginx + MySQL + PHP这种网站服务器架构。</li><li>LAMP指的是：Linux + Apache + MySQL  + PHP（有时也是指Perl或Python）。</li></ul></blockquote><a id="more"></a> <h2 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h2><ul><li>-?,-h ：查看帮助</li><li>-v ：显示版本号</li><li>-V : 显示版本号以及详细配置参数</li><li>-t  : 测试nginx配置文件是否正确，-t后可加具体文件路径，如若不加参数，可用此命令显示默认配置文件所在路径（/etc/nginx/nginx.conf）</li><li>-s signal : 发送信号来控制程序，信号有: stop, quit, reopen, reload<ul><li><code>nginx -s reload</code> ：修改配置后重新加载生效</li><li><code>nginx -s stop</code> ：快速停止nginx，立刻退出</li><li><code>nginx -s quit</code> ：完整有序的停止nginx，完成已接受的连接请求再退出</li></ul></li><li>-p prefix ：设置前缀路径 (default: /etc/nginx/)</li><li>-c filename ：设置配置文件 (默认: /etc/nginx/nginx.conf)</li><li>-g directives ：设置全局指令</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>我们可以通过配置文件，来实现在一台服务器上配置多个域名或者端口，我们每配置一个<code>server</code>，其实可理解为，就是将我们配置的路径（不同域名和端口）指向我们配置中的指定路径（服务器上的某文件夹），从而可以让客户端访问到此路径上的文件。默认解析当前路径下的<code>index.html</code>作为呈现页面。</p><h3 id="修改配置文件，加载所有子配置"><a href="#修改配置文件，加载所有子配置" class="headerlink" title="修改配置文件，加载所有子配置"></a>修改配置文件，加载所有子配置</h3><p>nginx的总配置文件默认是<code>/etc/nginx/nginx.conf</code>我们想加载开启多个服务配置，可用多个配置文件实现，每一个配置文件对应一个服务，我们先要在<code>nginx.conf</code>中加载所有配置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">    include       /etc/nginx/mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line">    <span class="comment">#gzip  on</span></div><div class="line">    ...</div><div class="line">    <span class="comment"># 加入此句话，即可加载conf.d文件夹下，所有conf后缀的文件。</span></div><div class="line">    include /etc/nginx/conf.d/*.conf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="添加一新的子配置文件"><a href="#添加一新的子配置文件" class="headerlink" title="添加一新的子配置文件"></a>添加一新的子配置文件</h3><p>每个<code>sever</code>的配置单独对应<code>conf.d</code>下的一个文件，以<code>.conf</code>为后缀。默认有一个<code>default.conf</code>我们可使用<code>cp default.conf custom.conf</code>复制出一份配置，然后修改即可。下面我们看下默认配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80; <span class="comment"># 1、默认的80端口</span></div><div class="line">    server_name  localhost; <span class="comment"># 2、服务名称，默认为本机，可改为相关域名</span></div><div class="line">    </div><div class="line">    <span class="comment">#charset koi8-r;</span></div><div class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></div><div class="line">    </div><div class="line">    location / &#123;</div><div class="line">        root   /usr/share/nginx/html; <span class="comment"># 3、将sever解析到那个路径下</span></div><div class="line">        index  index.html; <span class="comment"># 4、访问时默认加载解析的文件</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">#error_page  404              /404.html;</span></div><div class="line">    </div><div class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    error_page   500 502 503 504  /50x.html;</div><div class="line">    location = /50x.html &#123;</div><div class="line">        root   /usr/share/nginx/html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们只需要修改上述4处配置即可：</p><ul><li>listen：端口修改为非默认的80端口后，访问时需在域名后加<code>:port</code>来进行访问</li><li>server_name：默认的<code>localhost</code>即代表本机，可通过本机<code>ip</code>或指向此<code>ip</code>的域名来访问，我们如果有多个指向服务器<code>ip</code>的域名，可以通过配置此项，并且修改<code>配置3</code>的路径，来达到多个域名分别做不同解析的目的。</li></ul><p>最后需要记得执行<code>nginx -s reload</code>重新加载配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx（发音同engine x）是一个 Web服务器，也可以用作反向代理，负载平衡器和 HTTP缓存。本文主要介绍下nginx的使用方法，以及如何在一台服务器上配置多个域名和端口。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于nginx的相关应用场景我们这里不做详细说明，介绍两个相关名词，常见用于搭建web服务器的两种架构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LNMP指的是：Linux + Nginx + MySQL + PHP这种网站服务器架构。&lt;/li&gt;
&lt;li&gt;LAMP指的是：Linux + Apache + MySQL  + PHP（有时也是指Perl或Python）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://RunnanZhang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac系统中截图</title>
    <link href="http://RunnanZhang.github.io/mac-screenshot/"/>
    <id>http://RunnanZhang.github.io/mac-screenshot/</id>
    <published>2017-07-20T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.607Z</updated>
    
    <content type="html"><![CDATA[<p><code>Mac</code>系统下截图大体有两种方法：</p><ul><li><code>command + shift + 3</code> ：全屏幕截图</li><li><code>command + shift + 4</code> ：区域截图</li></ul><p>默认情况下，截图会保存到桌面，默认格式为<code>png</code>，以上两个操作，如果你同时按住<code>Ctrl</code>，截图会保存在剪切板中，可以使用<code>command + v</code>来进行粘贴。下面我们介绍如何进行更多个性化的操作与设置。</p><a id="more"></a> <h2 id="区域截图"><a href="#区域截图" class="headerlink" title="区域截图"></a>区域截图</h2><p>当我们按下<code>command + shift + 4</code>后，则开始了区域截图，我们可以拖动选择一片区域进行自定义截取，我们也可以进行如下后续辅助操作：</p><ul><li><p>按下空格键，鼠标会变成一个小相机，此时可利用鼠标点击指定窗体，便完成了对特定窗体截图。</p></li><li><p>我们在移动选择区域的过程中，不要松开鼠标或触摸板，可以进行如下操作：</p><ul><li>按住空格可以对当前区域进行拖动。</li><li>按住<code>shift</code>将锁定<code>X</code>轴或<code>Y</code>轴进行拖动。</li><li>按住<code>option</code>将按照区域圆心进行放大。</li></ul></li></ul><h2 id="个性化命令"><a href="#个性化命令" class="headerlink" title="个性化命令"></a>个性化命令</h2><h3 id="修改生成截图名称"><a href="#修改生成截图名称" class="headerlink" title="修改生成截图名称"></a>修改生成截图名称</h3><p>默认截图名称是由前缀名称加上截图时间命名的，我们可通过如下指令，进行个性化前缀：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture name CustomPreName</div><div class="line"><span class="comment"># 重启相关服务，使得设置立即生效</span></div><div class="line">killall SystemUIServer</div></pre></td></tr></table></figure><h3 id="修改默认截图存放位置"><a href="#修改默认截图存放位置" class="headerlink" title="修改默认截图存放位置"></a>修改默认截图存放位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture location ~/Pictures/Screenshots</div><div class="line">killall SystemUIServer</div></pre></td></tr></table></figure><h3 id="修改默认截图格式"><a href="#修改默认截图格式" class="headerlink" title="修改默认截图格式"></a>修改默认截图格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture <span class="built_in">type</span> jpg</div><div class="line">killall SystemUIServer</div></pre></td></tr></table></figure><h3 id="去掉-恢复阴影"><a href="#去掉-恢复阴影" class="headerlink" title="去掉/恢复阴影"></a>去掉/恢复阴影</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture <span class="built_in">disable</span>-shadow -bool <span class="literal">true</span></div><div class="line">defaults write com.apple.screencapture <span class="built_in">disable</span>-shadow -bool <span class="literal">false</span></div><div class="line">killall SystemUIServer</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;系统下截图大体有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;command + shift + 3&lt;/code&gt; ：全屏幕截图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command + shift + 4&lt;/code&gt; ：区域截图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，截图会保存到桌面，默认格式为&lt;code&gt;png&lt;/code&gt;，以上两个操作，如果你同时按住&lt;code&gt;Ctrl&lt;/code&gt;，截图会保存在剪切板中，可以使用&lt;code&gt;command + v&lt;/code&gt;来进行粘贴。下面我们介绍如何进行更多个性化的操作与设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://RunnanZhang.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac下加密文件</title>
    <link href="http://RunnanZhang.github.io/mac-encryption-file/"/>
    <id>http://RunnanZhang.github.io/mac-encryption-file/</id>
    <published>2017-07-17T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.604Z</updated>
    
    <content type="html"><![CDATA[<p>由于<code>Mac</code>系统下<code>Spotlight</code>工具的强大，我们如若想存储一些隐私文件，不被人所知，有如下两种方法：</p><ul><li>单纯的隐藏文件，在<code>Finder</code>中看不到，但是<code>Spotlight</code>依然可以搜索到。</li><li>我们可以制作一个加密的映像文件——<code>dmg</code>格式。<code>dmg</code>格式相当于<code>windows</code>中的<code>iso</code>。可以随意拷贝，使用时类似加载光盘的效果。</li></ul><a id="more"></a> <h2 id="Mac下隐藏文件"><a href="#Mac下隐藏文件" class="headerlink" title="Mac下隐藏文件"></a>Mac下隐藏文件</h2><ul><li>隐藏文件：<code>chflags hidden ~/Library</code></li><li>显示文件 ：<code>chflags nohidden ~/Library</code> </li></ul><h2 id="制作dmg映像文件"><a href="#制作dmg映像文件" class="headerlink" title="制作dmg映像文件"></a>制作dmg映像文件</h2><ul><li><p>利用磁盘管理工具新建一磁盘映像。<br><img src="/images/mac/new-dmg.png" alt=""></p><p>​</p></li><li><p>选择待加密的文件夹，随后选择加密方法以及映像格式，映像格式选择读写即可，选择压缩则会压缩文件，读写即是在原来基础上加密，并且可以随时扩展。<br><img src="/images/mac/new-dmg-info.png" alt=""></p><p>​</p></li><li><p>点击存储后，开始制作映像文件，制作完毕后我们会得到一个<code>dmg</code>文件。使用时双击此文件，系统则会自动加载，输入密码后可访问加密内容。使用完毕后，去桌面推出此<code>dmg</code>光盘即可。<br><img src="/images/mac/new-dmg-complete.png" alt=""></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于&lt;code&gt;Mac&lt;/code&gt;系统下&lt;code&gt;Spotlight&lt;/code&gt;工具的强大，我们如若想存储一些隐私文件，不被人所知，有如下两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单纯的隐藏文件，在&lt;code&gt;Finder&lt;/code&gt;中看不到，但是&lt;code&gt;Spotlight&lt;/code&gt;依然可以搜索到。&lt;/li&gt;
&lt;li&gt;我们可以制作一个加密的映像文件——&lt;code&gt;dmg&lt;/code&gt;格式。&lt;code&gt;dmg&lt;/code&gt;格式相当于&lt;code&gt;windows&lt;/code&gt;中的&lt;code&gt;iso&lt;/code&gt;。可以随意拷贝，使用时类似加载光盘的效果。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://RunnanZhang.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>QSS自定义滚动条</title>
    <link href="http://RunnanZhang.github.io/qt-custom-qscrollbar/"/>
    <id>http://RunnanZhang.github.io/qt-custom-qscrollbar/</id>
    <published>2017-07-06T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.609Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述如何通过<code>qss</code>自定义滚动条<code>QScrollBar</code>，我们先以实现一个扁平化的滚动条为例，效果如下图所示。</p><p><img src="/images/qt/flat-qscrollbar.png" alt=""></p><a id="more"></a> <h2 id="扁平化滚动条实现"><a href="#扁平化滚动条实现" class="headerlink" title="扁平化滚动条实现"></a>扁平化滚动条实现</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">:vertical</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#f0f0f0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">:horizontal</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#f0f0f0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:vertical</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#cdcdcd</span>;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:horizontal</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#cdcdcd</span>;</div><div class="line">    <span class="attribute">min-width</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:vertical</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:horizontal</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#a6a6a6</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::sub-line</span><span class="selector-pseudo">:vertical</span>, <span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::add-line</span><span class="selector-pseudo">:vertical</span>,</div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::sub-line</span><span class="selector-pseudo">:horizontal</span>, <span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::add-line</span><span class="selector-pseudo">:horizontal</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*make sure the background is solid style.*/</span></div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::add-page</span><span class="selector-pseudo">:vertical</span>, <span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::sub-page</span><span class="selector-pseudo">:vertical</span>,</div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::add-page</span><span class="selector-pseudo">:horizontal</span>, <span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::sub-page</span><span class="selector-pseudo">:horizontal</span> &#123;</div><div class="line">    <span class="attribute">background</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在<code>windows</code>中，如果不设置<code>add-page,sub-page:background: none;</code>，则背景将会变为网格样式。<code>mac</code>系统下无此特性。</p><h2 id="自定义背景图片"><a href="#自定义背景图片" class="headerlink" title="自定义背景图片"></a>自定义背景图片</h2><p>通过上面的例子，我们可以用设置背景色的方式，来实现扁平化风格的滚动条，如果我们想有更绚丽的效果，可以通过修改背景图片，来自定义滚动条。我们以纵向为例，参考代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">:vertical</span> &#123;</div><div class="line">    <span class="attribute">background</span>: white;</div><div class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:vertical</span> &#123;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">border-width</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">0px</span> <span class="number">4px</span>;</div><div class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(:/images/scrollbar.png) <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">4</span> repeat repeat;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::add-page</span><span class="selector-pseudo">:vertical</span>, <span class="selector-tag">QScrollBar</span><span class="selector-pseudo">::sub-page</span><span class="selector-pseudo">:vertical</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">8px</span>;</div><div class="line">    <span class="attribute">border-width</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">0px</span> <span class="number">4px</span>;</div><div class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(:/images/scrollbar_bg.png) <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">4</span> repeat repeat;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="默认隐藏滚动条"><a href="#默认隐藏滚动条" class="headerlink" title="默认隐藏滚动条"></a>默认隐藏滚动条</h2><p>现代风格的软件中，很多情况下滚动条默认是隐藏的，当鼠标进入相关区域后，显示当前区域的滚动条，这样做节省了空间，提高了整体观感。如微信的PC版本，Github客户端等均为此风格。实现方式也很简单，就是在鼠标进入和离开目标区域时，分别显示和隐藏滚动条即可，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ui-&gt;listWidget-&gt;installEventFilter(<span class="keyword">this</span>);</div><div class="line">ui-&gt;listWidget-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);</div><div class="line"></div><div class="line"><span class="keyword">bool</span> Widget::eventFilter(QObject *obj, QEvent *e)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(obj == ui-&gt;listWidget)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(e-&gt;type() == QEvent::Enter)</div><div class="line">        &#123;</div><div class="line">            obj-&gt;setProperty(<span class="string">"verticalScrollBarPolicy"</span>, <span class="string">"ScrollBarAsNeeded"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e-&gt;type() == QEvent::Leave)</div><div class="line">        &#123;</div><div class="line">            obj-&gt;setProperty(<span class="string">"verticalScrollBarPolicy"</span>, <span class="string">"ScrollBarAlwaysOff"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> QWidget::eventFilter(obj, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用<code>QObject::setProperty</code>方法是为了适配多个窗体的情况，代码可复用，只需条件中添加<code>obj == ui-&gt;listWidget2</code>即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://qtdebug.com/qt-flat-scrollbar/" target="_blank" rel="external">QSS 实现的扁平滚动条</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲述如何通过&lt;code&gt;qss&lt;/code&gt;自定义滚动条&lt;code&gt;QScrollBar&lt;/code&gt;，我们先以实现一个扁平化的滚动条为例，效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/qt/flat-qscrollbar.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>PImpl机制以及Qt的D-Pointer实现</title>
    <link href="http://RunnanZhang.github.io/cpp-pimpl/"/>
    <id>http://RunnanZhang.github.io/cpp-pimpl/</id>
    <published>2017-06-06T00:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.595Z</updated>
    
    <content type="html"><![CDATA[<p><code>PImpl</code>是 <code>Pointer to implementation</code>的缩写， 是C++ 在构建导出库接口时特有的技术手段。 即是将类<code>Class</code>中所有私有变量以及私有方法，封装在一单独的实现类<code>ClassImpl</code>中。我们在<code>Class</code>中通过一指向<code>ClassImpl</code>的私有指针，访问这些私有数据。而<code>ClassImpl</code>类的具体定义和实现，我们放入<code>cpp</code>中。Qt中的<code>D-Pointer</code>技术，便是<code>PImpl</code>机制的一种实现方式。</p><p>优点：</p><ul><li>使得程序接口有着稳定的<code>ABI</code>（应用程序二进制接口），即不会打破二进制兼容。</li><li>降低了程序编译依赖，从而缩短编译时间。</li><li>数据隐藏，使得头文件很干净，不包含实现细节，可以直接作为 API 参考。</li></ul><p>缺点：</p><ul><li>实现者需要做更多工作。</li><li>由于子类需要访问，此机制对<code>protected</code>方法不奏效。</li><li>由于数据的隐藏，多少造成了代码可读性下降。</li><li>运行时性能被轻微的连累，尤其调用的函数为虚函数时。</li></ul><a id="more"></a> <p>关于二进制兼容的问题，在<a href="http://zhangrunnan.com/cpp-binary-compatibility/" target="_blank" rel="external">C++的二进制兼容</a>一文中有详细解释，这里不再赘述。下面我们通过介绍Qt的<code>D-Pointer</code>的实现细节，来理解PImpl机制。</p><h2 id="Qt中D-Pointer的实现"><a href="#Qt中D-Pointer的实现" class="headerlink" title="Qt中D-Pointer的实现"></a>Qt中D-Pointer的实现</h2><ul><li>Person.h</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonPrivate</span>;</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    Q_DECLARE_PRIVATE(Person)</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Person();</div><div class="line">    ~Person();</div><div class="line">    <span class="function">QString <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</div><div class="line"></div><div class="line">signals:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calcRequested</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    QScopedPointer&lt;PersonPrivate&gt; d_ptr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>Person_p.h</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonPrivate</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    Q_DECLARE_PUBLIC(Person)</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    PersonPrivate(Person *parent);</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>;</div><div class="line">    </div><div class="line">    QString name;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Person * <span class="keyword">const</span> q_ptr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li>Person.cpp</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person_p.h"</span></span></div><div class="line"></div><div class="line">Person::Person() : d_ptr(<span class="keyword">new</span> PersonPrivate(<span class="keyword">this</span>))</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">~Person() &#123;&#125;</div><div class="line"></div><div class="line">QString Person::name() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    Q_D(<span class="keyword">const</span> Person);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> d-&gt;name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Person::setName(<span class="keyword">const</span> QString &amp;name)</div><div class="line">&#123;</div><div class="line">    Q_D(<span class="keyword">const</span> Person);</div><div class="line">    d-&gt;name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">PersonPrivate::PersonPrivate(Person *parent) : q_ptr(parent)</div><div class="line">&#123;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> PersonPrivate::calc()</div><div class="line">&#123;</div><div class="line">    Q_Q(Person);</div><div class="line"></div><div class="line">    emit q-&gt;calcRequested();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="相关宏定义及作用"><a href="#相关宏定义及作用" class="headerlink" title="相关宏定义及作用"></a>相关宏定义及作用</h2><p>以上所有用到的宏定义，均放在<code>qglobal.h</code>中。下面我们一一介绍。</p><h3 id="Q-DECLARE-PRIVATE、Q-D"><a href="#Q-DECLARE-PRIVATE、Q-D" class="headerlink" title="Q_DECLARE_PRIVATE、Q_D"></a>Q_DECLARE_PRIVATE、Q_D</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> T *<span class="title">qGetPtrHelper</span><span class="params">(T *ptr)</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Wrapper&gt; <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">typename</span> Wrapper::<span class="function">pointer <span class="title">qGetPtrHelper</span><span class="params">(<span class="keyword">const</span> Wrapper &amp;p)</span> </span>&#123; <span class="keyword">return</span> p.data(); &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PRIVATE(Class) \</span></div><div class="line">    <span class="keyword">inline</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr)); &#125; \</div><div class="line">    <span class="keyword">inline</span> <span class="keyword">const</span> Class##<span class="function">Private* <span class="title">d_func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> Class##Private *&gt;(qGetPtrHelper(d_ptr)); &#125; \</div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>##<span class="title">Private</span>;</span></div><div class="line">    </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_D(Class) Class##Private * const d = d_func()</span></div></pre></td></tr></table></figure><p><code>Q_DECLARE_PRIVATE</code>看似复杂，其实就是封装了<code>d_func()</code>函数，目的就是让我们在多种不同情况下，可以方便地拿到并使用私有类指针<code>d_ptr</code> 。<code>Q_D</code>宏对<code>d_func()</code>进行再次封装，让我们可以免去每次定义的繁琐，直接使用<code>d</code>指针，此指针即为我们想要的<code>d_ptr</code>。下面我们进行更详细的理解以及相关注意事项：</p><ul><li>利用<code>d_func()</code>函数，可以避免我们每次直接拿<code>d_ptr</code>指针进行类型转换（因为我们有可能会在子类中使用此方法，具体我们将在后面的拓展中详述）。</li><li>在<code>d_func()</code>中，我们为什么不直接使用<code>d_ptr</code> ，而要借助<code>qGetPtrHelper()</code>函数呢？利用此函数，是为了<strong>适配我们使用智能指针的情况</strong>，因为此时我们要拿到真正的指针，需要调用<code>d_ptr.data()</code>。</li><li>在<code>const</code>函数中使用<code>Q_D</code>，此时将调用<code>d_func()</code>的<code>const</code>版本，我们必须要利用<code>Q_D(const Person)</code>这种写法拿到正确的<code>const</code>指针（否则会提示无法转换）。这样封装也间接保证了程序的正确性，而不是直接拿到<code>d_ptr</code>指针进行操作 。</li><li><code>d_ptr</code>的定义是要放在暴露给用户的头文件中，如此命名有时会打破我们的命名规范，此时可以利用<code>Q_DECLARE_PRIVATE_D(m_dPtr, Person)</code>这个宏来进行自定义的命名。看到这个宏，我们不得不感慨Qt封装的细致得当。</li><li>既然上面提到了使用智能指针，这里多说几句，我们利用<strong>前置声明的方式</strong>来使用<code>QScopedPointer</code>时，我们必须要有非内联的构造、析构、赋值运算符。即不可以用默认生成的。具体可参见<code>QScopedPointer</code>文档中的<code>Forward Declared Pointers</code>部分。</li></ul><h3 id="Q-DECLARE-PUBLIC、Q-Q"><a href="#Q-DECLARE-PUBLIC、Q-Q" class="headerlink" title="Q_DECLARE_PUBLIC、Q_Q"></a>Q_DECLARE_PUBLIC、Q_Q</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_DECLARE_PUBLIC(Class)                                    \</span></div><div class="line">    <span class="function"><span class="keyword">inline</span> Class* <span class="title">q_func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Class *&gt;(q_ptr); &#125; \</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> Class* <span class="title">q_func</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Class *&gt;(q_ptr); &#125; \</div><div class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span></div><div class="line">    </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_Q(Class) Class * const q = q_func()</span></div></pre></td></tr></table></figure><p>同理，我们在私有类中，有时候需要调用主类的方法，这两个宏的作用就是为了可以在私有类中拿到主类的指针。我们在私有类的构造函数中传入主类指针，并赋值给<code>q_ptr</code>。因为这里是拿到主类的指针，并不存在智能指针的问题，所以此处并没有借助<code>qGetPtrHelper()</code>函数。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>有了上面的讲解，我们到这里可以思考一个问题，假如我们的类有很多的子类，那么我们岂不是每一个子类都需要定义一个<code>d_ptr</code>。每一个<code>private</code>类都需要有一个<code>q_ptr</code>的指针么？Qt中当然不会如此实现，所以就有了下面的优化版本。</p><ul><li><p>首先我们在基类<code>QObject</code>中将<code>d_ptr</code>变为<code>protected</code>类型，并在基类中添加一<code>protected</code>类型的构造函数，供子类使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QObject</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">protected</span>：</div><div class="line">    QObject(QObjectPrivate &amp;dd, QObject *parent = <span class="number">0</span>); </div><div class="line">    QScopedPointer&lt;QObjectData&gt; d_ptr;</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>所有的私有类均继承于<code>QObjectPrivate</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWidgetPrivate</span> :</span> <span class="keyword">public</span> QObjectPrivate</div><div class="line">&#123;</div><div class="line">    Q_OBJECT</div><div class="line">    Q_DECLARE_PUBLIC(QWidget)</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ul><p>下面我们在看看<code>QWidget</code>和<code>QObject</code>的构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">QWidget::QWidget(QWidget *parent, Qt::WindowFlags f)     </div><div class="line">        : QObject(*<span class="keyword">new</span> QWidgetPrivate, <span class="number">0</span>), QPaintDevice()  </div><div class="line">&#123; </div><div class="line">    ... </div><div class="line">&#125;</div><div class="line"></div><div class="line">QObject::QObject(QObject *parent)</div><div class="line">    : d_ptr(<span class="keyword">new</span> QObjectPrivate)</div><div class="line">&#123;</div><div class="line">    Q_D(QObject);</div><div class="line">    d_ptr-&gt;q_ptr = <span class="keyword">this</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">QObject::QObject(QObjectPrivate &amp;dd, QObject *parent)</div><div class="line">    : d_ptr(&amp;dd)</div><div class="line">&#123;</div><div class="line">    Q_D(QObject);</div><div class="line">    d_ptr-&gt;q_ptr = <span class="keyword">this</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>到这里，总算真相大白，<code>QWidget</code>中并没有出现<code>d_ptr</code>指针，原来是从<code>Qbject</code>继承而来。<code>QObject</code>中我们新添加的那个<code>protected</code>构造函数传入一个<code>QWidgetPrivate</code>，用此给<code>QObject</code>中的<code>d_ptr</code>赋值，而这便是我们唯一的<code>d_ptr</code>。现在总算真正理解之前<code>d_func()</code>中那些类型转换的作用，就是<strong>保证我们可以拿到当前正确类型的private指针</strong>。</p><p>那么同理，<code>ObjectPrivate</code>是继承于<code>QObjectData</code>，而在<code>QObjectData</code>中有着<code>QObject *q_ptr;</code>。 所有<code>QObject</code>子类的私有类，均继承于<code>ObjectPrivate</code>，故而子类中也不会出现<code>q_ptr</code>，在<code>QObject</code>的构造函数中，我们把<code>this</code>指针给其赋值，在通过使用<code>Q_Q</code>宏，我们<strong>同样可以拿到正确类型的主类<code>q</code>指针</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们完全可以不借助<code>Qt</code>这些宏来实现<code>PImpl</code>，其实只需要构建<code>private</code>类，将其放入<code>cpp</code>中，就已经实现了<code>PImpl</code>。不过利用这些宏，可以简单的实现出<code>Qt</code>风格的数据隐藏，我们可以利用上面<code>Person</code>类的简化版实现，当然假如我们的类需要被继承，我们也可以参考拓展中的方式，利用继承<code>ObjectPrivate</code>类的方式实现，不过需要注意，想要使用此类，我们需要在<code>pro</code>中添加<code>QT += core-private</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://wiki.c2.com/?PimplIdiom" target="_blank" rel="external">Pimpl idiom</a></li><li><a href="https://wiki.qt.io/D-Pointer/zh" target="_blank" rel="external">D-Pointer</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;PImpl&lt;/code&gt;是 &lt;code&gt;Pointer to implementation&lt;/code&gt;的缩写， 是C++ 在构建导出库接口时特有的技术手段。 即是将类&lt;code&gt;Class&lt;/code&gt;中所有私有变量以及私有方法，封装在一单独的实现类&lt;code&gt;ClassImpl&lt;/code&gt;中。我们在&lt;code&gt;Class&lt;/code&gt;中通过一指向&lt;code&gt;ClassImpl&lt;/code&gt;的私有指针，访问这些私有数据。而&lt;code&gt;ClassImpl&lt;/code&gt;类的具体定义和实现，我们放入&lt;code&gt;cpp&lt;/code&gt;中。Qt中的&lt;code&gt;D-Pointer&lt;/code&gt;技术，便是&lt;code&gt;PImpl&lt;/code&gt;机制的一种实现方式。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得程序接口有着稳定的&lt;code&gt;ABI&lt;/code&gt;（应用程序二进制接口），即不会打破二进制兼容。&lt;/li&gt;
&lt;li&gt;降低了程序编译依赖，从而缩短编译时间。&lt;/li&gt;
&lt;li&gt;数据隐藏，使得头文件很干净，不包含实现细节，可以直接作为 API 参考。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现者需要做更多工作。&lt;/li&gt;
&lt;li&gt;由于子类需要访问，此机制对&lt;code&gt;protected&lt;/code&gt;方法不奏效。&lt;/li&gt;
&lt;li&gt;由于数据的隐藏，多少造成了代码可读性下降。&lt;/li&gt;
&lt;li&gt;运行时性能被轻微的连累，尤其调用的函数为虚函数时。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://RunnanZhang.github.io/tags/C/"/>
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++的二进制兼容</title>
    <link href="http://RunnanZhang.github.io/cpp-binary-compatibility/"/>
    <id>http://RunnanZhang.github.io/cpp-binary-compatibility/</id>
    <published>2017-05-31T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.592Z</updated>
    
    <content type="html"><![CDATA[<p>在深入了解前，首先我们要明确两个概念：二进制兼容和源码兼容。</p><ul><li><p>二进制兼容：在升级库文件的时候，不必<strong>重新编译</strong>使用此库的可执行文件或其他库文件，并且程序的功能不被破坏。</p></li><li><p>源码兼容：在升级库文件的时候，不必<strong>修改</strong>使用此库的可执行文件或其他库文件的<strong>源代码</strong>，只需重新编译应用程序，即可使程序的功能不被破坏。</p></li></ul><a id="more"></a> <h2 id="ABI和API"><a href="#ABI和API" class="headerlink" title="ABI和API"></a>ABI和API</h2><blockquote><p>应用二进制接口（application binary interface，缩写为 ABI）描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。<code>ABI</code>涵盖了各种细节，如：数据类型的大小、布局和对齐；调用约定等。</p></blockquote><p>在了解二进制兼容和源码兼容两个定义以后，我们再看与其类似且对应的两个概念：<code>ABI</code>和<code>API</code>。<code>ABI</code>不同于<code>API</code>（应用程序接口），<code>API</code>定义了源代码和库之间的接口，因此同样的代码可以在支持这个<code>API</code>的任何系统中编译，然而<code>ABI</code>允许编译好的目标代码在使用兼容<code>ABI</code>的系统中无需改动就能运行。</p><p>举个例子，在Qt和Java两种跨平台程序中，<code>API</code>像是Qt的接口，Qt有着通用接口，源代码只需要在支持Qt的环境下编译即可。<code>ABI</code>更像是Jvm，只要支持Jvm的系统上，都可以运行已有的Java程序。</p><h2 id="C-的ABI"><a href="#C-的ABI" class="headerlink" title="C++的ABI"></a>C++的ABI</h2><p><code>ABI</code>更像是一个产品的使用说明书，同理C++的<code>ABI</code>就是如何使用C++生成可执行程序的一张说明书。编译器会根据这个说明书，生成二进制代码。C++的<code>ABI</code>在不同的编译器下会略有不同。</p><p>C++<code>ABI</code>的部分内容举例：</p><ul><li>函数参数传递的方式，比如 x86-64 用寄存器来传函数的前 4 个整数参数 </li><li>虚函数的调用方式，通常是 vptr/vtbl 然后用 vtbl[offset] 来调用 </li><li>struct 和 class 的内存布局，通过偏移量来访问数据成员 </li></ul><p>综上所述，<strong>如果可执行程序通过以上说明书访问动态链接库A，以及此库的升级版本A+，若按此说明书上的方法，可以无痛的使用A和A+，那么我们就称库A的这次升级是二进制兼容的。</strong></p><h2 id="破坏二进制兼容的几种常见方式"><a href="#破坏二进制兼容的几种常见方式" class="headerlink" title="破坏二进制兼容的几种常见方式"></a>破坏二进制兼容的几种常见方式</h2><ul><li>添加新的虚函数</li><li>不导出或者移除一个导出类</li><li>改变类的继承</li><li>改变虚函数声明时的顺序（偏移量改变，导致调用失败）</li><li>添加新的非静态成员变量（类的内存布局改变，偏移量也发生变化）</li><li>改变非静态成员变量的声明顺序</li></ul><h2 id="不会破坏二进制兼容的几种常见方式"><a href="#不会破坏二进制兼容的几种常见方式" class="headerlink" title="不会破坏二进制兼容的几种常见方式"></a>不会破坏二进制兼容的几种常见方式</h2><ul><li>添加非虚函数（包括构造函数）</li><li>添加新的类</li><li>添加Qt中的信号槽</li><li>在已存在的枚举类型中添加一个枚举值</li><li>添加新的静态成员变量</li><li>修改成员变量名称（偏移量未改变）</li><li>添加<code>Q_OBJECT</code>,<code>Q_PROPERTY</code>, <code>Q_ENUMS</code> ,<code>Q_FLAGS</code>宏，添加这些宏都是修改了moc生成的文件，而不是类本身</li></ul><p>只要我们知道了程序是以什么方式访问动态库的（C++的ABI)，那么我们就很好判断，哪些操作会破坏二进制兼容。更多方式请参见<a href="https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C%2B%2B" target="_blank" rel="external">Policies/Binary Compatibility Issues With C++ </a>  </p><h2 id="解决二进制兼容问题的相关方法"><a href="#解决二进制兼容问题的相关方法" class="headerlink" title="解决二进制兼容问题的相关方法"></a>解决二进制兼容问题的相关方法</h2><ul><li>使用<code>Bitflags</code>即位域</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint m1 : <span class="number">1</span>;</div><div class="line">uint m2 : <span class="number">3</span>;</div><div class="line">uint m3 : <span class="number">1</span>;</div></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uint m1 : <span class="number">1</span>;</div><div class="line">uint m2 : <span class="number">3</span>;</div><div class="line">uint m3 : <span class="number">1</span>;</div><div class="line">uint m4 : <span class="number">2</span>; <span class="comment">// new member without breaking binary compatibility.</span></div></pre></td></tr></table></figure><ul><li>使用<code>PImpl</code>机制，详情参见<a href="http://zhangrunnan.com/cpp-pimpl/" target="_blank" rel="external">PImpl机制以及Qt的D-Pointer实现</a></li><li>使用静态库（当然也随之带来一系列弊端）</li></ul><h2 id="C-抽象类和Java的接口"><a href="#C-抽象类和Java的接口" class="headerlink" title="C++抽象类和Java的接口"></a>C++抽象类和Java的接口</h2><p>读到这里大家也许会奇怪，作者是不是放错地方了？其实不然，只是在我们了解二进制兼容后，可以更好地理解这组概念。之前我一直认为C++的抽象类就类似于Java的接口，现在发现，如果把一个C++的抽象类作为动态库的接口发布，那将是毁灭的。因为你无法增加虚函数，无法增加成员变量，这使得这个接口变得非常的不友好。这也就是Java接口的优势所在。Java 实际上把 C/C++ 的 linking 这一步骤推迟到 class loading 的时候来做，便不存在上述二进制兼容的问题。</p><blockquote><p>理解Java二进制兼容的关键是要理解延迟绑定（Late Binding）。延迟绑定是指Java直到运行时才检查类、域、方法的名称，而不象C/C++的编译器那样在编译期间就清除了类、域、方法的名称，代之以偏移量数值——这是Java二进制兼容得以发挥作用的关键。<br>由于采用了延迟绑定技术， 方法、域、类的名称直到运行时才解析，意味着只要域、方法等的名称（以及类型）一样，类的主体可以任意替换。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C%2B%2B" target="_blank" rel="external">Policies/Binary Compatibility Issues With C++ </a></li><li><a href="http://www.cppblog.com/Solstice/archive/2011/03/09/141401.html" target="_blank" rel="external">C++ 工程实践(4)：二进制兼容性</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在深入了解前，首先我们要明确两个概念：二进制兼容和源码兼容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二进制兼容：在升级库文件的时候，不必&lt;strong&gt;重新编译&lt;/strong&gt;使用此库的可执行文件或其他库文件，并且程序的功能不被破坏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;源码兼容：在升级库文件的时候，不必&lt;strong&gt;修改&lt;/strong&gt;使用此库的可执行文件或其他库文件的&lt;strong&gt;源代码&lt;/strong&gt;，只需重新编译应用程序，即可使程序的功能不被破坏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://RunnanZhang.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Windows打开资源管理器并选中文件</title>
    <link href="http://RunnanZhang.github.io/windows-explorer-select/"/>
    <id>http://RunnanZhang.github.io/windows-explorer-select/</id>
    <published>2017-03-23T16:30:00.000Z</published>
    <updated>2017-09-16T14:28:43.624Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>windows</code>中，我们若想打开资源管理器，并选中文件，可以利用<code>explorer.exe</code>的<code>select</code>命令。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shellapi.h&gt;</span></span></div><div class="line"></div><div class="line">ShellExecute(<span class="literal">NULL</span>,(LPCWSTR)<span class="string">L"open"</span>, (LPCWSTR)<span class="string">L"explorer.exe"</span>, (LPCTSTR)<span class="string">L" /select, E:\\a.txt"</span>, <span class="literal">NULL</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure><a id="more"></a><p>注意：</p><ul><li>我们程序中自己写的代码路径，要加转义字符，<strong>转义字符是给编译器看的</strong>，实际存入字符串中的并非是<code>\\</code>，而是一个<code>\</code>。当然我们从变量中读取的路径则可直接使用。</li><li>在<code>cmd</code>命令中有些路径必须使用反斜杠<code>\</code>，虽然<code>windows</code>中路径反斜杠和斜杠均可，但<code>cmd</code>中，我们传递参数均用斜杠<code>/</code>，所以路径中假如使用<code>/</code>则会出错，产生歧义。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;中，我们若想打开资源管理器，并选中文件，可以利用&lt;code&gt;explorer.exe&lt;/code&gt;的&lt;code&gt;select&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;shellapi.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ShellExecute(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,(LPCWSTR)&lt;span class=&quot;string&quot;&gt;L&quot;open&quot;&lt;/span&gt;, (LPCWSTR)&lt;span class=&quot;string&quot;&gt;L&quot;explorer.exe&quot;&lt;/span&gt;, (LPCTSTR)&lt;span class=&quot;string&quot;&gt;L&quot; /select, E:\\a.txt&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://RunnanZhang.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Qt中设置透明度</title>
    <link href="http://RunnanZhang.github.io/qt-set-opacity/"/>
    <id>http://RunnanZhang.github.io/qt-set-opacity/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.612Z</updated>
    
    <content type="html"><![CDATA[<p>Qt中设置窗体透明度的方式有三种：</p><ul><li><code>QWidget::setWindowOpacity</code></li><li><code>QPainter::setOpacity</code></li><li><code>QGraphicsOpacityEffect</code></li></ul><a id="more"></a> <h2 id="1、QWidget-setWindowOpacity"><a href="#1、QWidget-setWindowOpacity" class="headerlink" title="1、QWidget::setWindowOpacity"></a>1、<code>QWidget::setWindowOpacity</code></h2><p><code>windowOpacity</code>是<code>QWidget</code>的属性，我们可以通过此接口对QWidget一族设置不透明度，不过若<code>Widget</code>有父指针，则利用此接口设置会失败。此时可用以下两种方式替换。</p><h2 id="2、QPainter-setOpacity"><a href="#2、QPainter-setOpacity" class="headerlink" title="2、QPainter::setOpacity"></a>2、<code>QPainter::setOpacity</code></h2><p>利用<code>QPainter</code>设置是最原始有效的方式，当我们在<code>paintEvent</code>中绘制时，可以利用<code>QPainter</code>设置透明度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Widget::paintEvent(QPaintEvent *event)</div><div class="line">&#123;</div><div class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</div><div class="line">    painter.setOpacity(<span class="number">0.6</span>);</div><div class="line">    painter.drawPixmap(pos(),  pix.scaled(size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="3、QGraphicsOpacityEffect"><a href="#3、QGraphicsOpacityEffect" class="headerlink" title="3、QGraphicsOpacityEffect"></a>3、<code>QGraphicsOpacityEffect</code></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">QGraphicsOpacityEffect *effect = newQGraphicsOpacityEffect(<span class="keyword">this</span>);</div><div class="line">effect-&gt;setOpacity(<span class="number">0.5</span>);</div><div class="line">widget-&gt;setGraphicsEffect(effect);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Qt中设置窗体透明度的方式有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QWidget::setWindowOpacity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QPainter::setOpacity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QGraphicsOpacityEffect&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>程序编译的四部曲</title>
    <link href="http://RunnanZhang.github.io/compile-process/"/>
    <id>http://RunnanZhang.github.io/compile-process/</id>
    <published>2017-01-01T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.590Z</updated>
    
    <content type="html"><![CDATA[<p>提到编译我们并不陌生，静态编译、动态编译等相关概念也经常出现，那么编译到底是什么，编译的过程又是如何呢？其实我们平时提到的编译，仅仅是编译过程中的一部分，真正的编译过程可总结为如下四步：</p><ul><li>预编译</li><li>编译</li><li>汇编</li><li>连接</li></ul><a id="more"></a> <h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>删除所有<code>#define</code>，展开所有宏定义；删除注释；处理<code>#include</code>等等。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>将预处理后的文件进行一系列词法分析、语法分析以及优化等。此步骤需要.h文件，换言之，编译器需要知道，我程序所用的方法都是声明过的，都是合法的！</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>程序经过预编译、编译、汇编，此时已经输出目标文件（win下的.obj，Linux下的.o)。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接即是将之前生成的目标文件以及我们的库进行链接，生成可执行程序的过程，这里的可执行程序所指范围很广，可以是exe、lib、dll 等。此步骤所需文件为.lib文件以及上一步生成的目标文件，用其进行重定位！此步骤中静态编译、动态编译有很大区别，下面我们介绍下这两种模式的区别。</p><h2 id="静态编译"><a href="#静态编译" class="headerlink" title="静态编译"></a>静态编译</h2><h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><p>进行重定位，即在.lib文件中找到我们所需内容（并不是将所有指令拷贝）嵌入到对应目标文件中，和目标文件一起打包生成为最后的可执行程序。此时可执行程序可能会很大。</p><h3 id="生成和使用"><a href="#生成和使用" class="headerlink" title="生成和使用"></a>生成和使用</h3><p>编译静态库仅会生成.lib文件，无需其他支持。<br>使用此静态库，链接过程中需要.lib文件，一旦编译完毕，即打包成最终可执行程序，运行时则无需此.lib文件。</p><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><h3 id="链接过程-1"><a href="#链接过程-1" class="headerlink" title="链接过程"></a>链接过程</h3><p>.lib文件仅仅为索引文件，真正的核心内容都在dll中，链接过程仅仅用.lib文件进行重定位。个人理解此重定位是将目标文件中调用的函数（动态库中）的代码，替代为.lib里所存储的此函数在dll里的索引位置，一起打包为最后的可执行程序。这样在程序运行时，程序可以顺利的解析dll（找到相应方法在dll中的正确地址），从而使程序顺利的进行！</p><h3 id="生成和使用-1"><a href="#生成和使用-1" class="headerlink" title="生成和使用"></a>生成和使用</h3><p>编译动态库最终生成dll，lib，exp等等文件。lib为索引文件，dll为核心指令文件，exp是一个中间文件，我们可不予理会。<br>使用此动态库，链接过程需要.lib文件，运行时需要dll文件。</p><h3 id="动态导出-导入符"><a href="#动态导出-导入符" class="headerlink" title="动态导出/导入符"></a>动态导出/导入符</h3><p><code>__declspec(dllexport)</code> <code>__declspec(dllimport)</code>顾名思义，这俩符号是动态库导出时候才用到的。如果主程序调用静态库，包含的头文件还加<code>__declspec(dllimport)</code>，这样会导致直接编译不过。</p><ul><li><code>__declspec(dllexport)</code>这个符号非常重要，假如不加，我们动态编译后，生成的dll会有问题，而且还缺少lib和exp等文件，没有lib文件，意味着主程序想要使用这个动态库，则四部曲中的链接步骤无法进行。</li><li><code>__declspec(dllimport)</code>这个符号相对于导出，就显得不重要了。这个符号会出现在供主程序包含的.h文件中，假如没有此符号，编译主程序时大多数不受影响！仅当我们的导出方法中含有static方法时，则必须加此符号，否则会导入失败。</li></ul><p>为了使我们头文件用同一版本，我们只需定义一个通用宏替代本身导入导出符号即可，具体做法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MOUDLE_LIBRARY)</span></div><div class="line"><span class="meta">#  <span class="meta-keyword">define</span> MOUDLE_EXPORT __declspec(dllexport)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#  <span class="meta-keyword">define</span> MOUDLE_EXPORT __declspec(dllimport)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>这样在本项目中，我们只需定义宏<code>MOUDLE_LIBRARY</code>，此时<code>MOUDLE_EXPORT</code>即为导出符号。当其他项目使用此库，包含其头文件时，由于没有定义此宏，则<code>MOUDLE_EXPORT</code>即为导入符号。</p><p>附带提一句，在VS中，编译时关于对C++基本库的使用是动态还是静态，我们要想将其打包进我们的程序中，可以在选项中调节（MT/MD等选项）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到编译我们并不陌生，静态编译、动态编译等相关概念也经常出现，那么编译到底是什么，编译的过程又是如何呢？其实我们平时提到的编译，仅仅是编译过程中的一部分，真正的编译过程可总结为如下四步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预编译&lt;/li&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;li&gt;汇编&lt;/li&gt;
&lt;li&gt;连接&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Compile" scheme="http://RunnanZhang.github.io/tags/Compile/"/>
    
  </entry>
  
  <entry>
    <title>Qt中设置程序UAC启动权限</title>
    <link href="http://RunnanZhang.github.io/qt-set-uac/"/>
    <id>http://RunnanZhang.github.io/qt-set-uac/</id>
    <published>2016-12-19T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.614Z</updated>
    
    <content type="html"><![CDATA[<p><code>UAC(User Account Control)</code> 在Windows中，当某程序需要以管理员身份运行时（程序图标上有一个小盾牌），系统会弹出UAC提示。本篇我们谈一下，如何利用<code>qmake</code>，设置UAC。</p><a id="more"></a> <h2 id="VS中设置UAC"><a href="#VS中设置UAC" class="headerlink" title="VS中设置UAC"></a>VS中设置UAC</h2><p><img src="/images/qt/set-uac.png" alt=""></p><h2 id="Qt中设置UAC"><a href="#Qt中设置UAC" class="headerlink" title="Qt中设置UAC"></a>Qt中设置UAC</h2><p>在Qt中，我们可以通过变量<code>QMAKE_LFLAGS</code>，来为Linker中增加Flags。这样，我们<code>qmake</code>后，VS中相对项也会对应修改。下面为<code>QMAKE_LFLAGS</code>文档中解释：</p><blockquote><p>Specifies a general set of flags that are passed to the linker. If you need to change the flags used for a particular platform or type of project, use one of the specialized variables for that purpose instead of this variable.</p></blockquote><h3 id="利用QMAKE-LFLAGS设置UAC权限等级："><a href="#利用QMAKE-LFLAGS设置UAC权限等级：" class="headerlink" title="利用QMAKE_LFLAGS设置UAC权限等级："></a>利用QMAKE_LFLAGS设置UAC权限等级：</h3><p>经测试，下面两种情况无通用做法，第一种必须加转义符号，而第二种不可以加。</p><ul><li><p>直接利用Qt Creator编译：<br><code>QMAKE_LFLAGS += /MANIFESTUAC:\&quot;level=\&#39;requireAdministrator\&#39; uiAccess=\&#39;false\&#39;\&quot;</code></p></li><li><p>利用qmake转vcproj的情况：<br><code>QMAKE_LFLAGS += /MANIFESTUAC:&quot;level=&#39;requireAdministrator&#39;uiAccess=&#39;false&#39;&quot;</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UAC(User Account Control)&lt;/code&gt; 在Windows中，当某程序需要以管理员身份运行时（程序图标上有一个小盾牌），系统会弹出UAC提示。本篇我们谈一下，如何利用&lt;code&gt;qmake&lt;/code&gt;，设置UAC。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
      <category term="Windows" scheme="http://RunnanZhang.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows设置程序开机启动</title>
    <link href="http://RunnanZhang.github.io/windows-auto-start/"/>
    <id>http://RunnanZhang.github.io/windows-auto-start/</id>
    <published>2016-12-18T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.622Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章为大家介绍，在Windows系统下，如何利用注册表设置开机启动程序。</p><a id="more"></a> <h2 id="启动项在注册表中位置"><a href="#启动项在注册表中位置" class="headerlink" title="启动项在注册表中位置"></a>启动项在注册表中位置</h2><p>用户启动项均存储在注册表中如下位置：<br><code>&quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;</code></p><p><img src="/images/windows/auto-start.png" alt=""></p><p>如图可知，我们只需在Run中添加一项，键值即是程序绝对路径以及启动参数，当系统启动时，会将Run中所有项对应程序启动。</p><h2 id="利用QSetting写入注册表"><a href="#利用QSetting写入注册表" class="headerlink" title="利用QSetting写入注册表"></a>利用QSetting写入注册表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REGEDIT_AUTO_START_PATH <span class="meta-string">"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> REGEDIT_KEY <span class="meta-string">"MagicAssistant"</span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> MagicAssistant::autoStart(<span class="keyword">bool</span> is_start)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// QSettings::NativeFormat可用于读取注册表.</span></div><div class="line">    <span class="function">QSettings <span class="title">regedit</span><span class="params">(REGEDIT_AUTO_START_PATH, QSettings::NativeFormat)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(is_start) &#123;</div><div class="line">        QString sAppPath = QApplication::applicationFilePath();</div><div class="line">        regedit.setValue(REGEDIT_KEY, QVariant(QDir::toNativeSeparators(sAppPath)));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        regedit.setValue(REGEDIT_KEY, QVariant());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="启动路径"><a href="#启动路径" class="headerlink" title="启动路径"></a>启动路径</h2><p>windows自启动程序的默认启动路径为<code>system32</code>或者<code>system64</code>文件夹，而非exe所在目录，所以我们程序中使用相对路径时一定要注意，在程序开始可通过设置当前路径解决此问题。</p><p><code>QDir::setCurrent(a.applicationDirPath());</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章为大家介绍，在Windows系统下，如何利用注册表设置开机启动程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
      <category term="Windows" scheme="http://RunnanZhang.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows注册全局热键</title>
    <link href="http://RunnanZhang.github.io/windows-global-hotkey/"/>
    <id>http://RunnanZhang.github.io/windows-global-hotkey/</id>
    <published>2016-12-16T13:30:12.000Z</published>
    <updated>2017-09-16T14:28:43.627Z</updated>
    
    <content type="html"><![CDATA[<p>说起热键，大家一定不陌生，程序的热键有两种：</p><ul><li>程序内部：当程序处于<code>active</code>状态时，才响应的键盘事件。</li><li>全局热键：顾名思义，任何地方均可调用的热键。比如 我们最常用的QQ截图<code>Ctrl+Alt+A</code>。</li></ul><p>下面我们就介绍下，在<code>Windows</code>操作系统中，如何使用全局热键。</p><a id="more"></a><h2 id="1、向Windows注册"><a href="#1、向Windows注册" class="headerlink" title="1、向Windows注册"></a>1、向Windows注册</h2><p>向操作系统注册快捷键，本着先到先得的原则，先注册的程序即可抢得此快捷键。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">void</span> Class::initHotKey()</div><div class="line">&#123;</div><div class="line">    RegisterHotKey((HWND)winId(), <span class="number">1</span>, MOD_CONTROL | MOD_ALT | MOD_NOREPEAT, <span class="string">'M'</span>);</div><div class="line">    RegisterHotKey((HWND)winId(), <span class="number">2</span>, MOD_CONTROL | MOD_ALT | MOD_NOREPEAT, <span class="string">'N'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p><code>BOOL RegisterHotKey(HWND hWnd，int id，UINT fsModifiers，UINT vk);</code></p><ul><li><code>hWnd</code> : 窗口句柄</li><li><code>id</code> : 一个唯一标识号，我上面代码随便写的1,2，目前虽并未出错，但正确使用方法如下：</li></ul><blockquote><p>定义热键的标识符。调用线程中的其他热键，不能使用同样的标识符。应用程序必须定义一个<code>0X0000-0xBFFF</code>范围的值。一个共享的动态链接库（DLL）必须定义一个范围为<code>0xC000-0xFFFF</code>的值(<code>GlobalAddAtom</code>函数返回该范围）。为了避免与其他动态链接库定义的热键冲突，一个DLL必须使用<code>GlobalAddAtom</code>函数获得热键的标识符。</p></blockquote><ul><li><code>fsModifiers</code> : 若要产生WM_HOTKEY消息，必须同时按下fsModifiers和vk参数定义的键。</li></ul><table><thead><tr><th>键</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>MOD_ALT</td><td>0x0001</td><td>按下的可以是任一<code>Alt</code>键</td></tr><tr><td>MOD_SHIFT</td><td>0x0004</td><td>按下的可以是任一<code>Shift</code>键</td></tr><tr><td>MOD_WIN</td><td>0x0008</td><td>按下的可以是任一<code>Windows</code>键</td></tr><tr><td>MOD_NOREPEAT</td><td>0x4000</td><td>键盘自动重复不会产生多个热键通知</td></tr><tr><td>MOD_CONTROL</td><td>0x0002</td><td>按下的可以是任一<code>Ctrl</code>键</td></tr></tbody></table><ul><li><code>vk</code> : 定义热键的虚拟键码。</li></ul><h2 id="2、程序中处理WM-HOTKEY消息"><a href="#2、程序中处理WM-HOTKEY消息" class="headerlink" title="2、程序中处理WM_HOTKEY消息"></a>2、程序中处理<code>WM_HOTKEY</code>消息</h2><p>我们注册了快捷键，当按下时，系统就会通知到我们的指定程序，我们只需要接收，辨别Id来识别我们注册的快捷键，做相应处理即可：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Class::nativeEvent(<span class="keyword">const</span> QByteArray &amp;eventType, <span class="keyword">void</span> *message, <span class="keyword">long</span> *result)</div><div class="line">&#123;</div><div class="line">    Q_UNUSED(result);</div><div class="line">    <span class="comment">// 通过消息类型，判断操作系统。</span></div><div class="line">    <span class="keyword">if</span>(eventType == <span class="string">"windows_generic_MSG"</span>)</div><div class="line">    &#123;</div><div class="line">        MSG* msg = <span class="keyword">static_cast</span>&lt;MSG*&gt;(message);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(msg-&gt;message == WM_HOTKEY) &#123;</div><div class="line">            <span class="keyword">switch</span>(msg-&gt;wParam) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">            doSomething1();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">                doSomething2();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="3、程序退出时，注销相关注册。"><a href="#3、程序退出时，注销相关注册。" class="headerlink" title="3、程序退出时，注销相关注册。"></a>3、程序退出时，注销相关注册。</h2><p>在程序退出时，我们一定要注销我们所注册的快捷键，否则将无法再次注册，直到重启为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class::~Class()</div><div class="line">&#123;</div><div class="line">    UnregisterHotKey((HWND)winId(), <span class="number">1</span>);</div><div class="line">    UnregisterHotKey((HWND)winId(), <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起热键，大家一定不陌生，程序的热键有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序内部：当程序处于&lt;code&gt;active&lt;/code&gt;状态时，才响应的键盘事件。&lt;/li&gt;
&lt;li&gt;全局热键：顾名思义，任何地方均可调用的热键。比如 我们最常用的QQ截图&lt;code&gt;Ctrl+Alt+A&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们就介绍下，在&lt;code&gt;Windows&lt;/code&gt;操作系统中，如何使用全局热键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://RunnanZhang.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>程序编译过程中编码的作用</title>
    <link href="http://RunnanZhang.github.io/encoding-compile/"/>
    <id>http://RunnanZhang.github.io/encoding-compile/</id>
    <published>2016-12-14T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.597Z</updated>
    
    <content type="html"><![CDATA[<p>在读过<a href="/encoding/">编码与编码</a>一文中，我们介绍了不同情况下编码所指代的不同含义，这里我们主要谈一谈，在程序编译的过程中，编码所起到的作用。首先我们要阐述如下几个定义：</p><ul><li>源文件编码：文件其实就是一堆字节所组成的，生成这些字节序列的方式即源码编码。</li><li>编译器执行编码：编译器最终生成执行文件时的编码。</li></ul><p>总结来看，编译过程中，编译器通过<strong>识别源文件的编码</strong>，将其<strong>按照执行编码进行转换输出</strong>，生成目标文件，最终目标文件经过链接生成可执行程序。所以当我们程序运行后，程序内部的各种数据，均是执行编码，而不是源码编码。那么不同的编译器是如何<strong>识别源文件编码</strong>并如何<strong>设置执行编码</strong>呢？</p><a id="more"></a> <h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><ul><li>识别源文件：可以正确识别<code>UTF-8 with BOM</code>。否则编译器一概不识别，全部当做locale（简体中文系统即为GB2312）处理。</li><li>执行编码：VS2005以上，无论源码如何，执行编码均为locale。</li></ul><p>由此看来，大微软的编译器果然性格孤僻，要求严苛。那么我们如何设置执行编码呢？</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ol><li><code>C++11</code>中，<code>u8</code>，<code>u</code>，<code>U</code>等前缀，可告知编译器按照何种执行编码输出此字符串。分别对应<code>UTF-8</code>，<code>UTF-16</code>，<code>UTF-32</code>。</li><li>可设置当前文件执行编码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> _MSC_VER &gt;= 1600</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> execution_character_set(<span class="meta-string">"utf-8"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></li></ol><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><ul><li>识别源文件：如无特殊设置，认为源码均是<code>UTF-8 without BOM</code>。</li><li>执行编码：如无特殊设置，默认均为<code>UTF-8 without BOM</code> 。</li></ul><p><code>GCC</code>这种全部统一为<code>UTF-8</code>格式，对我们来说很是方便。所以我们的开发中，建议全部使用<code>UTF-8</code>格式，当然这里的<code>UTF-8</code>格式，指的是标准格式，即无<code>BOM</code>。</p><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><ul><li><code>-finput-charset</code> 指定源文件的编码。</li><li><code>-fexec-charset</code> 指定多字节字符串(const char*)常量在编译后的程序里保存的编码集。</li><li><code>-fwide-exec-charset</code> 指定宽字节字符串(const wchar_t*)常量在编译后的程序里的保存的编码集。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在读过&lt;a href=&quot;/encoding/&quot;&gt;编码与编码&lt;/a&gt;一文中，我们介绍了不同情况下编码所指代的不同含义，这里我们主要谈一谈，在程序编译的过程中，编码所起到的作用。首先我们要阐述如下几个定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源文件编码：文件其实就是一堆字节所组成的，生成这些字节序列的方式即源码编码。&lt;/li&gt;
&lt;li&gt;编译器执行编码：编译器最终生成执行文件时的编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来看，编译过程中，编译器通过&lt;strong&gt;识别源文件的编码&lt;/strong&gt;，将其&lt;strong&gt;按照执行编码进行转换输出&lt;/strong&gt;，生成目标文件，最终目标文件经过链接生成可执行程序。所以当我们程序运行后，程序内部的各种数据，均是执行编码，而不是源码编码。那么不同的编译器是如何&lt;strong&gt;识别源文件编码&lt;/strong&gt;并如何&lt;strong&gt;设置执行编码&lt;/strong&gt;呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Compile" scheme="http://RunnanZhang.github.io/tags/Compile/"/>
    
      <category term="Encoding" scheme="http://RunnanZhang.github.io/tags/Encoding/"/>
    
  </entry>
  
  <entry>
    <title>Git中使远程仓库覆盖本地修改</title>
    <link href="http://RunnanZhang.github.io/git-reset/"/>
    <id>http://RunnanZhang.github.io/git-reset/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.602Z</updated>
    
    <content type="html"><![CDATA[<p>由于Git是分布式版本控制系统，和SVN的集中式管理不同，每个人电脑上均为完整的库，不用必须与服务器连接。所以当我们做了某些修改，想要放弃此修改时，在SVN中，我们可以删除这部分代码，然后重新update即可。那么在git中如何操作呢，我们将利用<code>reset</code>、<code>clean</code>命令解决此问题。这些命令不指定路径则默认在当前路径下执行。</p><a id="more"></a> <h2 id="reset命令"><a href="#reset命令" class="headerlink" title="reset命令"></a>reset命令</h2><p><code>git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]</code>：将当前的分支<code>reset</code>到指定的<code>&lt;commit&gt;</code>或者<code>HEAD</code>，如果不显示指定<code>commit</code>，默认是<code>HEAD</code>，即最新的一次提交。</p><ul><li><p><code>--hard</code> 重设（reset） index和working directory，自从<code>&lt;commit&gt;</code>以来在working directory中的任何改变都被丢弃，并把<code>HEAD</code>指向<code>&lt;commit&gt;</code>。此为彻底回退。</p></li><li><p><code>--soft</code> index和working directory中的内容不作任何改变，仅仅把<code>HEAD</code>指向<code>&lt;commit&gt;</code>。这个模式的效果是，执行完毕后，自从<code>&lt;commit&gt;</code>以来的所有改变都会显示在git status的”Changes to be committed”中</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#回退所有内容到上一个版本 </span></div><div class="line">git reset HEAD^ </div><div class="line"></div><div class="line"><span class="comment">#回退test.cpp这个文件的版本到上一个版本 </span></div><div class="line">git reset HEAD^ test.cpp </div><div class="line"></div><div class="line"><span class="comment">#向前回退到第n个版本 </span></div><div class="line">git reset –-soft HEAD~n</div><div class="line"></div><div class="line"><span class="comment">#将本地的状态回退到和远程的一样,此将删除本地修改代码。</span></div><div class="line">git reset –-hard origin/master </div><div class="line"></div><div class="line"><span class="comment">#回退到某个版本</span></div><div class="line">git reset <span class="string">'版本号'</span> </div><div class="line"></div><div class="line"><span class="comment">#回退到上一次提交的状态，按照某一次的commit完全反向的进行一次commit </span></div><div class="line">git revert HEAD</div></pre></td></tr></table></figure><h2 id="clean命令"><a href="#clean命令" class="headerlink" title="clean命令"></a>clean命令</h2><p><code>git clean</code>经常和<code>git reset --hard</code>一起结合使用。 <code>reset</code>只影响被track过的文件，<code>clean</code>可删除没有track过的文件。结合这两个命令能让你的工作目录完全回到一个指定的<code>&lt;commit&gt;</code>的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#显示待删除文件.</span></div><div class="line">git clean -n</div><div class="line"></div><div class="line"><span class="comment">#删除当前目录下所有没有track过的文件. 不会删除.gitignore里面指定的文件。</span></div><div class="line">git clean -f</div><div class="line"></div><div class="line"><span class="comment">#删除当前目录下没有被track过的文件夹.</span></div><div class="line">git clean -d</div><div class="line"></div><div class="line"><span class="comment">#删除.gitignore里所指定的文件. </span></div><div class="line">git clean -x</div><div class="line"></div><div class="line"><span class="comment">#组合使用，全部删除。</span></div><div class="line">git clean -xdf</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于Git是分布式版本控制系统，和SVN的集中式管理不同，每个人电脑上均为完整的库，不用必须与服务器连接。所以当我们做了某些修改，想要放弃此修改时，在SVN中，我们可以删除这部分代码，然后重新update即可。那么在git中如何操作呢，我们将利用&lt;code&gt;reset&lt;/code&gt;、&lt;code&gt;clean&lt;/code&gt;命令解决此问题。这些命令不指定路径则默认在当前路径下执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://RunnanZhang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>QDesigner中验证QSS格式是否有效的方法</title>
    <link href="http://RunnanZhang.github.io/qt-validate-style/"/>
    <id>http://RunnanZhang.github.io/qt-validate-style/</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.617Z</updated>
    
    <content type="html"><![CDATA[<p>QDesigner中编辑样式表，如下图所示，可以及时验证所写QSS格式是否正确。这个功能是<code>QtGui</code>的内部功能，并未放开。我们可直接包含其头文件，使用其方法。</p><p><img src="/images/qt/editStyle.png" alt=""></p><a id="more"></a> <h2 id="使用QCss-Parser"><a href="#使用QCss-Parser" class="headerlink" title="使用QCss::Parser"></a>使用QCss::Parser</h2><p>使用QCss类相关代码：</p><ul><li>方式：可包含<code>#include &lt;QtGui/5.7.0/QtGui/private/qcssparser_p.h&gt;</code> </li><li>此法为<code>QtGui</code>中方法，正常链接<code>QT += gui</code>即可使用.</li></ul><h3 id="节选自QDesigner源码中函数"><a href="#节选自QDesigner源码中函数" class="headerlink" title="节选自QDesigner源码中函数"></a>节选自QDesigner源码中函数</h3><blockquote><p>源码位置:<code>C:\Qt\Qt5.7.0\5.7\Src\qttools\src\designer\src\lib\shared\stylesheeteditor.cpp</code></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> StyleSheetEditorDialog::isStyleSheetValid(<span class="keyword">const</span> QString &amp;styleSheet) &#123;</div><div class="line">QCss::<span class="function">Parser <span class="title">parser</span><span class="params">(styleSheet)</span></span>;</div><div class="line">  QCss::StyleSheet sheet;</div><div class="line">  <span class="keyword">if</span> (parser.parse(&amp;sheet))</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  QString fullSheet = QStringLiteral(<span class="string">"* &#123; "</span>);</div><div class="line">  fullSheet += styleSheet;</div><div class="line">  fullSheet += QLatin1Char(<span class="string">'&#125;'</span>);</div><div class="line">  QCss::<span class="function">Parser <span class="title">parser2</span><span class="params">(fullSheet)</span></span>;</div><div class="line">  <span class="keyword">return</span> parser2.parse(&amp;sheet);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;QDesigner中编辑样式表，如下图所示，可以及时验证所写QSS格式是否正确。这个功能是&lt;code&gt;QtGui&lt;/code&gt;的内部功能，并未放开。我们可直接包含其头文件，使用其方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/qt/editStyle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Qt" scheme="http://RunnanZhang.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>编码与‘编码’</title>
    <link href="http://RunnanZhang.github.io/encoding/"/>
    <id>http://RunnanZhang.github.io/encoding/</id>
    <published>2016-12-11T16:00:00.000Z</published>
    <updated>2017-09-16T14:28:43.600Z</updated>
    
    <content type="html"><![CDATA[<p>编码——是我们平时经常提到的一个词，在搞清楚这个词之前，我们先来看一段有趣的对话：</p><blockquote><p>这篇博文写得行云流水，博主你<strong>方便</strong>的时候把二维码给我，<strong>大爷</strong>我今天要打赏！<br>好的先生，感谢您的拜读，我这就把二维码传给您。<br>恩，我先去<strong>方便</strong>一下，回来就给您打赏。<strong>大爷</strong>的，今天晚饭没喝粥，突然肚子疼。<br>哈哈，您身体快赶上老<strong>大爷</strong>了。</p></blockquote><p>编码就像上述对话中的词语，懂的人自然知道，不同语义下其含义不同。人们所说的编码，有时指字符集，有时又用它指字符编码，有时却又指码位。下面我们就介绍下这些究竟是什么。</p><ul><li><strong>字符集</strong>：一系列字符的集合。</li><li><strong>码位</strong>：将抽象的字符集中每一个字符映射到一个整数，此整数即为码位。</li><li><strong>字符编码</strong>：按照某种规则，将程序数据（字节序列）和字符集的码位进行互转的方法。</li></ul><a id="more"></a> <p>下面以我们常说的Unicode为例，Unicode是一个<strong>编码字符集</strong>，并不是一种<strong>字符编码</strong>，由于微软习惯把<code>UTF-16LE(Little Endian)</code>称做Unicode编码，所以误导了大部分人。<code>UTF-8</code> <code>UTF-16(LE/BE)</code> <code>UTF-32(LE/BE)</code>才是针对Unicode字符集的编码方式。</p><blockquote><p>简单的概述下编码的历史，期间具体过程不在本文再做阐述。最开始美国佬认为ASCII即可表示世界上所有字符，后来经过不断拓展，经历了ISO和Unicode从两败俱伤走向强强联手阶段，最终形成了现在的Unicode。目前的Unicode字符分为17组编排，0x0000 至 0x10FFFF，每组称为平面（Plane），而每平面拥有65536个码位，共1114112个。足够涵盖世界上任何国家的所有字符。</p></blockquote><h2 id="几种常见编码"><a href="#几种常见编码" class="headerlink" title="几种常见编码"></a>几种常见编码</h2><ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码） ：标准形式为7bit，ASCII字符集有127个字符，ASCII编码采用<code>0xxxxxxx</code>格式的无符号整数。</li><li>Latin1 ：同样为单字节编码，<strong>向下兼容ASCII</strong>，其码位范围是<code>0x00-0xFF</code>。<code>0x00-0x7F</code>之间完全和ASCII一致，<code>0x80-0x9F</code>之间是控制字符，<code>0xA0-0xFF</code>之间是文字符号。其编码方式为8bit无符号整数即本身码位值。</li><li>ANSI ： 为一个标准，不代表具体某种特定编码。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；不同 ANSI 编码之间互不兼容，当信息在国际间交流时，<strong>无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中</strong>。ANSI编码表示英文字符时用一个字节，表示中文用两个或四个字节。</li><li><code>UTF-8( 8-bit Unicode Transformation Format)</code> <code>UTF-16(LE/BE)</code> <code>UTF-32(LE/BE)</code></li></ul><h2 id="几种UTF编码"><a href="#几种UTF编码" class="headerlink" title="几种UTF编码"></a>几种UTF编码</h2><p>下面讲解下几种UTF编码分别是如何工作的。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><table><thead><tr><th>Unicode码位(十六进制)</th><th>UTF-8 字节流(二进制)</th></tr></thead><tbody><tr><td>00000000 - 0000007F</td><td>0xxxxxxx</td></tr><tr><td>00000080 - 000007FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>00000800 - 0000FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>00010000 - 001FFFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>00200000 - 03FFFFFF</td><td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>04000000 - 7FFFFFFF</td><td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>按照上述模板，可以将<code>Unicode</code>所有码位，换算成<code>UTF-8</code>模式的字节序列（将码位的二进制形式依次填充模板中的<code>x</code>）。并且<strong><code>UTF-8</code>完全向下兼容<code>ASCII</code> 和<code>Latin-1</code>。</strong></p><p><code>UTF-8</code>的特点是对<strong>不同码位范围</strong>的字符使用<strong>不同长度</strong>的编码。对于<code>0x00-0x7F</code>之间的字符，<code>UTF-8</code>编码与<code>ASCII</code>编码完全相同。<code>UTF-8</code>编码的最大长度是6个字节。从上表可以看出，6字节模板有31个x，即可以容纳31位二进制数字。Unicode的最大码位<code>0x7FFFFFFF</code>也只有31位。</p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p><code>UTF-16</code>是用2字节表示一个<code>Unicode</code>的码位，所以<strong>和ASCII并不兼容</strong>，因为就算<code>0x00-0xFF</code>范围内的编码，也需要用2字节表示。<code>UTF-16</code>在表示上有大小端之分，即字节序。</p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p><code>UTF-32</code> 是一种非常费内存但是转换方法简单的编码，每个字符均为4字节，以32位无符号整数为单位 ，这种做法的好处是无需转换，正好对应了<code>Unicode</code>的码位。<code>Unicode</code>的<code>UTF-32</code>编码就是其对应的32位无符号整数。同样的<code>UTF-32</code>也有大小端之分。</p><h2 id="关于字节序"><a href="#关于字节序" class="headerlink" title="关于字节序"></a>关于字节序</h2><p>通过上面的描述，我们知道字节序有<code>Little Endian</code> <code>Big Endian</code> 之分。在我们传输过程中，要根据字节序，进行相应的编解码，才可以的到准确的数据。</p><blockquote><p><code>endian</code>一词来源于乔纳森·斯威夫特的小说格列佛游记。小说中，小人国为水煮蛋该从大的一端剥开还是小的一端剥开而争论，争论的双方分别被称为<code>Big Endian</code> <code>Little Endian</code>。同样的战争也爆发在我们字节传送的过程中。1980年，<code>Danny Cohen</code>在其著名的论文<code>On Holy Wars and a Plea for Peace</code>中为平息一场关于字节该以什么样的顺序传送的争论而引用了该词。</p></blockquote><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><p><code>Unicode</code>标准建议用<code>BOM（Byte Order Mark）</code>来区分字节序，即在传输字节流前，先传输被作为<code>BOM</code>的字符“零宽无中断空格”。这个字符的编码是<code>FEFF</code>，而反过来的<code>FFFE（UTF-16）</code>和<code>FFFE0000（UTF-32）</code>在<code>Unicode</code>中都是未定义的码位，不应该出现在实际传输中。</p><p>下表是各种<code>UTF</code>编码的<code>BOM</code>：</p><table><thead><tr><th>UTF编码</th><th>Byte Order Mark (BOM)</th></tr></thead><tbody><tr><td>UTF-8 without BOM</td><td>无</td></tr><tr><td>UTF-8 with BOM</td><td>EF BB BF</td></tr><tr><td>UTF-16LE</td><td>FF FE</td></tr><tr><td>UTF-16BE</td><td>FE FF</td></tr><tr><td>UTF-32LE</td><td>FF FE 00 00</td></tr><tr><td>UTF-32BE</td><td>00 00 FE FF</td></tr></tbody></table><p><strong>UTF-8本身并不需要用BOM来区分，因为他传输过程中没有字节序一说，仅仅是微软为其加上了BOM，用于识别UTF-8文件，其实并无作用。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编码——是我们平时经常提到的一个词，在搞清楚这个词之前，我们先来看一段有趣的对话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇博文写得行云流水，博主你&lt;strong&gt;方便&lt;/strong&gt;的时候把二维码给我，&lt;strong&gt;大爷&lt;/strong&gt;我今天要打赏！&lt;br&gt;好的先生，感谢您的拜读，我这就把二维码传给您。&lt;br&gt;恩，我先去&lt;strong&gt;方便&lt;/strong&gt;一下，回来就给您打赏。&lt;strong&gt;大爷&lt;/strong&gt;的，今天晚饭没喝粥，突然肚子疼。&lt;br&gt;哈哈，您身体快赶上老&lt;strong&gt;大爷&lt;/strong&gt;了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编码就像上述对话中的词语，懂的人自然知道，不同语义下其含义不同。人们所说的编码，有时指字符集，有时又用它指字符编码，有时却又指码位。下面我们就介绍下这些究竟是什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;字符集&lt;/strong&gt;：一系列字符的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;码位&lt;/strong&gt;：将抽象的字符集中每一个字符映射到一个整数，此整数即为码位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符编码&lt;/strong&gt;：按照某种规则，将程序数据（字节序列）和字符集的码位进行互转的方法。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Encoding" scheme="http://RunnanZhang.github.io/tags/Encoding/"/>
    
  </entry>
  
  <entry>
    <title>All Documents</title>
    <link href="http://RunnanZhang.github.io/sitemap/"/>
    <id>http://RunnanZhang.github.io/sitemap/</id>
    <published>2015-12-21T00:08:08.000Z</published>
    <updated>2018-08-30T14:38:32.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ul><li><a href="/cpp-binary-compatibility">C++的二进制兼容</a></li><li><a href="/cpp-pimpl">PImpl机制以及Qt的D-Pointer实现</a></li></ul><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><ul><li><a href="/compile-process">程序编译的四部曲</a></li><li><a href="/encoding-compile">程序编译过程中编码的作用</a></li></ul><h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><ul><li><a href="/encoding-compile">程序编译过程中编码的作用</a></li><li><a href="/encoding">编码与‘编码’</a></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="/git-reset">Git中使远程仓库覆盖本地修改</a></li></ul><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><ul><li><a href="/sitemap">All Documents</a></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="/linux-nginx-config">Nginx使用以及相关配置</a></li></ul><h2 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h2><ul><li><a href="/mac-encryption-file">Mac下加密文件</a></li><li><a href="/mac-screenshot">Mac系统中截图</a></li></ul><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><ul><li><a href="/cpp-pimpl">PImpl机制以及Qt的D-Pointer实现</a></li><li><a href="/qt-custom-menu-iconsize">修改QMenu中的Icon大小</a></li><li><a href="/qt-custom-qscrollbar">QSS自定义滚动条</a></li><li><a href="/qt-set-opacity">Qt中设置透明度</a></li><li><a href="/qt-set-uac">Qt中设置程序UAC启动权限</a></li><li><a href="/qt-system-translate">Qt中系统相关翻译</a></li><li><a href="/qt-validate-style">QDesigner中验证QSS格式是否有效的方法</a></li><li><a href="/windows-auto-start">Windows设置程序开机启动</a></li></ul><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li><a href="/qt-set-uac">Qt中设置程序UAC启动权限</a></li><li><a href="/windows-auto-start">Windows设置程序开机启动</a></li><li><a href="/windows-explorer-select">Windows打开资源管理器并选中文件</a></li><li><a href="/windows-global-hotkey">Windows注册全局热键</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/cpp-binary-compatibility&quot;&gt;C++的二进制兼容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Index" scheme="http://RunnanZhang.github.io/tags/Index/"/>
    
  </entry>
  
</feed>
